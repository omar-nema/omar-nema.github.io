


//var n = 12, // total number of nodes
//    m = 4, // number of distinct clusters
//    z = d3.scaleOrdinal(d3.schemeCategory20);

//keep runnning same sim?

//var centers = [
//    { x: width/8, y: height/2},
//    { x: 3*width/8, y: height/2},
//    { x: 5*width/8, y: height/2},
//    { x: 7*width/8, y: height/4}    
//];

//
//var centers = [
//    { x: width/2, y: height/2},
//    { x: width/2, y: height/2},
//    { x: width/2, y: height/2},
//    { x: width/2, y: height/2}    
//];


//structureing the addition..


//map maxes in each category
    //$('.slider').mouseover(mouseOverSlider).mouseleave(mouseLeaveSlider);    
  // $('.thumb').mousedown(mouseDownThumb).mouseover(function(){$(this).addClass('thumb-active')}).mouseout(function(){$(this).removeClass('thumb-active')});
//     $('.thumb').mousedown(mouseDownThumb).m;
    
//    nodes = nodes2[1]
//update(nodes)
//simulation.nodes(nodes)
//simulation.alpha(.1).restart()
//one array with max of each
    
//update doing its job
    //either circle doesn't contain, or ..
    

//function timer(){
//    nodes = riskslice[5]
//    update(nodes)
//    simulation.nodes(nodes)
//    simulation.alpha(.3).restart()    
//
//callback function when it's done


//timer
//on each tick


  
    //now go through nestedData and get array slices
    
//    for (i=0; i<nestedData.length; i++){
//        var nodeholder = [];
//        for (j=0; j<types.length; j++){
//            var currPoint = nestedData[i].values[j];
//            var firstPt = d3.range(currPoint.primaryAvg).map((datapt, indexnum) => {
//                var f = types.indexOf(currPoint.type);
//                radius = 9;
//                indexString = f + ',' + indexnum;
//                d = {cluster: f, r: radius, opacity: .4, indexnum: indexString};                
//                if (i == 0 ){
//                    if (!clusters[f] || (radius > clusters[f].r)) clusters[f] = d;                          
//                }
////                else {
////                    if (!clusters[f] || (radius > clusters[f].r)) clusters[f] = d;                         
////                }
////          
//                return d;
//            });
//            
//            //a series of cluster points
//            
////            nodeholder.push(firstPt);
//            var secPt = d3.range(currPoint.secAvg).map(() => {
//                var f = types.indexOf(currPoint.type);
//                radius = 9;
//                // x: centers[f].x + Math.random(), y: centers[f].y + Math.random()
//                d = {cluster: f, r: radius, opacity: 1,};
//                if (!clusters[f] || (radius > clusters[f].r)) clusters[f] = d;                
//                return d;   //do we need to add these to clusters?!  
////                d = {cluster: types.indexOf(currPoint.type), r: 9, opacity: 1};
////                if (!clusters[f] || (radius > clusters[f].r)) clusters[f] = d;                   
////                return d;
//            });            
//
//            //setting array = array of objects
//            nodeholder = nodeholder.concat(firstPt); 
//            nodeholder = nodeholder.concat(secPt);             
//        };
//        nodes2.push(nodeholder)
//    };    
    
//    for (i=0; i<nestedData.length; i++){
//        var nodeholder = [];
//        for (j=0; j<types.length; j++){
//            var currPoint = nestedData[i].values[j];
//            var firstPt = d3.range(currPoint.primaryAvg).map((datapt, indexnum) => {
//                var f = types.indexOf(currPoint.type);
//                radius = 9;
//                indexString = f + ',' + indexnum;
//                d = {cluster: f, r: radius, opacity: .4, indexnum: indexString};                
//                if (i == 0 ){
//                    if (!clusters[f] || (radius > clusters[f].r)) clusters[f] = d;                          
//                }
////                else {
////                    if (!clusters[f] || (radius > clusters[f].r)) clusters[f] = d;                         
////                }
////          
//                return d;
//            });
//            
//            //a series of cluster points
//            
////            nodeholder.push(firstPt);
//            var secPt = d3.range(currPoint.secAvg).map(() => {
//                var f = types.indexOf(currPoint.type);
//                radius = 9;
//                // x: centers[f].x + Math.random(), y: centers[f].y + Math.random()
//                d = {cluster: f, r: radius, opacity: 1,};
//                if (!clusters[f] || (radius > clusters[f].r)) clusters[f] = d;                
//                return d;   //do we need to add these to clusters?!  
////                d = {cluster: types.indexOf(currPoint.type), r: 9, opacity: 1};
////                if (!clusters[f] || (radius > clusters[f].r)) clusters[f] = d;                   
////                return d;
//            });            
//
//            //setting array = array of objects
//            nodeholder = nodeholder.concat(firstPt); 
//            nodeholder = nodeholder.concat(secPt);             
//        };
//        nodes2.push(nodeholder)
//    };
//    return nodes2;

//make nodes 2 only the diff
//change to diff node data structure?

//toggle a risk value

//
//nodes = nodes.concat(nodes, nodes2[2])
//update(nodes)
//simulation.nodes(nodes)
//simulation.alpha(.5).restart()


//    nodes = nodes2[currRiskVal];  
//    update(nodes2[currRiskVal]);
    


//    nodes = nodes2[currRiskVal];   
////    nodes = nodes.concat(nodes2[currRiskVal], nodes2[currRiskVal-1])
//
//    circles = chart.append('g')
//           // .datum(nodes)
//        
//            .selectAll('.circle')
////            .data(function(d){return d})
//            .data(nodes)
//            .enter().append('circle')
//            .attr('fill', (d) => colorscale(d.cluster)) 
//            .style('opacity', (d) => d.opacity)
//            .attr('stroke', 'white')
//            .attr('stroke-width', 1);
//    
//    
//chart.selectAll('.circle')
////            .data(function(d){return d})
//            .data(nodes)
//            .enter().append('circle')
//            .attr('fill', (d) => colorscale(d.cluster)) 
//            .style('opacity', (d) => d.opacity)
//            .attr('stroke', 'white')
//            .attr('stroke-width', 1);
    
    
 
    
//    .force("x", d3.forceX(width/2).strength(.05))
    
    //next nodes

    //create growing simulation first?
    


//function collide(alpha) {
//  var quadtree = d3.quadtree()
//      .x((d) => d.x)
//      .y((d) => d.y)
//      .addAll(nodes);
//  nodes.forEach(function(d) {
//    var r = d.r + maxRadius + Math.max(padding, clusterPadding),
//        nx1 = d.x - r,
//        nx2 = d.x + r,
//        ny1 = d.y - r,
//        ny2 = d.y + r;
//    quadtree.visit(function(quad, x1, y1, x2, y2) {
//      if (quad.data && (quad.data !== d)) {
//        var x = d.x - quad.data.x,
//            y = d.y - quad.data.y,
//            l = Math.sqrt(x * x + y * y),
//            r = d.r + quad.data.r + (d.cluster === quad.data.cluster ? padding : clusterPadding);
//        if (l < r) {
//          l = (l - r) / l * alpha;
//          d.x -= x *= l;
//          d.y -= y *= l;
//          quad.data.x += x;
//          quad.data.y += y;
//        }
//      }
//      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
//    });
//  });
//}
//
//function clustering(alpha) {  
//    nodes.forEach(function(d) {      
//      var cluster = clusters[d.cluster];
//    if (cluster === d ) return; 
//      var x = d.x - cluster.x,
//          y = d.y - cluster.y,
//          l = Math.sqrt(x * x + y * y),
//          r = d.r + cluster.r;
//      if (l !== r && l !== 0) {  
//        l = (l - r) / l * alpha;
//        d.x -= x *= l;
//        d.y -= y *= l;
//        cluster.x += x;
//        cluster.y += y;
//      }  
//    });
//}




//understand forces GROUND UP
//        .force("cluster", clustering)
//    .force("x", d3.forceX(width/2).strength(.02))
//    .force("y", d3.forceY(height/2).strength(.02))   

//timer + update - bringing in entirely new risk, or do we have a pile of data just sitting there?

//we need a function to pull each node to cluster center


//function force(alpha) {
//  for (var i = 0, n = nodes.length, node, k = alpha * 0.1; i < n; ++i) {
//    node = nodes[i];
//    node.vx -= node.x * k;
//    node.vy -= node.y * k;
//  }
//}


//// Move nodes toward cluster focus.
//function gravity(alpha) {
//  return function(d) {
//    // d.y += (d.cy - d.y) * alpha;
//    // d.x += (d.cx - d.x) * alpha;
//    d.y += (foci[d.choice].y - d.y) * alpha;
//    d.x += (foci[d.choice].x - d.x) * alpha;
//  };
//}
//
//function force(alpha) {
//  for (var i = 0, n = nodes.length, node, k = alpha * 0.1; i < n; ++i) {
//    node = nodes[i];
//    node.vx -= node.x * k;
//    node.vy -= node.y * k;
//  }
//}




//WHY ISN'T FORCE RESTART WRKING

//ARE CLUSTERS EVEN REQUIRED ?

// var nodes = d3.range(200).map(() => {
//    let i = Math.floor(Math.random() * m),
//        radius = 9,
//        d = {cluster: i, r: radius};
//    if (!clusters[i] || (radius > clusters[i].r)) clusters[i] = d;
//    return d;
//});
    //clusters are only in [0]?
    
    //try to move from one center to the next
    //generate for next risk value 
    //change x / u
//            .force("x", d3.forceX().strength(.5))
//        .force("y", d3.forceY().strength(.5))
    
    //time function updates nodes 1 by 1
//    .force("center", d3.forceCenter([300,100]))        
//    .force("collide", d3.forceCollide([10]))


//            .attr('cx', width/2)
//            .attr('cy', height/2)
    //      .attr('r', function(d){return d.r})


//save the footer plz
//@media only screen and (min-width: $breakpoint-3){
//
//    footer {
//    position: absolute;
//    bottom: 0;
//    left: 0;
//    width: 100%;
//    height: $footer-height;
//    }
//}

//endscatter

//
//.scatter-small {
//    
////define multiplication factor && make life easier    
//    
//    $card-title-fontsize: $smallFactor*1.9vw;
//
//    $small-hospitalquality-width: $smallFactor*$hospitalquality-width;
//    $small-hospitalquality-height: $cardratio * $small-hospitalquality-width;
//    $small-hospitalquality-top: 9.1%;
//    $small-hospitalquality-left: 0%;
//
//    $small-missingrx-width: $smallFactor*$missingrx-width;
//    $small-missingrx-height: $cardratio*$small-missingrx-width;
//    $small-missingrx-top: 2%;
//    $small-missingrx-left: 37%;
//
//    $small-personaldata-width: $smallFactor*18vw;
//    $small-personaldata-height: $cardratio * $small-personaldata-width;
//    $small-personaldata-top: 36%;
//    $small-personaldata-left: 45.5%;
//
//    $small-thesis-width: $smallFactor*$thesis-width;
//    $small-thesis-height: $cardratio*$small-thesis-width;
//    $small-thesis-top: 52%;
//    $small-thesis-left: 10%;
//
//    $small-narrative-width: $smallFactor*$narrative-width;
//    $small-narrative-height: $cardratio * $small-narrative-width;
//    $small-narrative-top: 70.25%;
//    $small-narrative-left: 45.5%;
//
//    $small-tools-width: $smallFactor*$tools-width;
//    $small-tools-height: $small-tools-width * $cardratio;
//    $small-tools-top: 16%;
//    $small-tools-left: 76.7%;
//
//    $small-table-width: $smallFactor*$table-width;
//    $small-table-height: $small-table-width * $cardratio;
//    $small-table-top: 51%;
//    $small-table-left: 71.25%;
//
//    $small-tea-width: $smallFactor*$tea-width;
//    $small-tea-height: $small-tea-width * $cardratio;
//    $small-tea-top: 75%;
//    $small-tea-left: 78%;
//    
//    .cardtitle {
//        font-size: $card-title-fontsize;
//    }
//    
//    .cardholder {
//        position: absolute;
//    }
//     #{$child1} {
//        width: $small-hospitalquality-width;
//        height: $small-hospitalquality-height;
//        top: $small-hospitalquality-top;
//        left: $small-hospitalquality-left;
//            .cardcontent p {
//                font-size: $small-font-size-factor * $small-hospitalquality-width;
//            }            
//        }     
//      #{$child2} {
//        width: $small-missingrx-width;
//        height: $small-missingrx-height;
//        top: $small-missingrx-top;
//        left:$small-missingrx-left;
//            .cardcontent p {
//                font-size: $small-font-size-factor * $small-missingrx-width;
//            }             
//    }
//    #{$child3}{
//        width: $small-personaldata-width;
//        height: $small-personaldata-height;
//        top: $small-personaldata-top;
//        left: $small-personaldata-left;
//            .cardcontent p {
//                font-size: $small-font-size-factor * $small-personaldata-width;
//            }            
//    }
//    #{$child4} {
//        width: $small-thesis-width;
//        height: $small-thesis-height;
//        top: $small-thesis-top;
//        left: $small-thesis-left;
//            .cardcontent p {
//                font-size: $small-font-size-factor * $small-thesis-width;
//            }            
//    }
//    #{$child5}  {
//        width: $small-narrative-width;
//        height: $small-narrative-height;
//        top: $small-narrative-top;
//        left: $small-narrative-left;
//            .cardcontent p {
//                font-size: $small-font-size-factor * $small-narrative-width;
//            }            
//    }
//    #{$child6}{
//        width: $small-tools-width;
//        height: $small-tools-height;
//        top: $small-tools-top;
//        left: $small-tools-left;
//            .cardcontent p {
//                font-size: $small-font-size-factor * $small-tools-width;
//            }            
//    }
//    #{$child7} {
//        width: $small-table-width;
//        height: $small-table-height;
//        top: $small-table-top;
//        left: $small-table-left;
//            .cardcontent p {
//                font-size: $small-font-size-factor * $small-table-width;
//            }            
//    }
//    #{$child8}{
//        width: $small-tea-width;
//        height: $small-tea-height;
//        top: $small-tea-top;
//        left: $small-tea-left;
//            .cardcontent p {
//                font-size: $small-font-size-factor * $small-tea-width;
//            }            
//    }
//}//endscatter
//


////////////////
//function getObjectValues(input){
//    output = [];
//    for(key in input) {
//        if(input.hasOwnProperty(key)) {
//            var value = input[key];
//            output.push(value);
//        }
//    }
//    return output;   
//};



//when is x and y added - create a cluster !1

//now create a cluster mofo

//var nodes = d3.range(0, num_nodes).map(function(o, i) {
//	return {
//		id: "node" + i,
//		x: foci.center.x + Math.random(),
//		y: foci.center.y + Math.random(),
//		radius: init_radius,
//		choice: "center",
//	}
//});


//
//    var xmax = d3.max(input, function(d){return d.primaryAvg}) + d3.max(input, function(d){return d.secAvg});
//    xscale.domain([0, xmax]);    
//    yscale.domain(types);
////var sorted = d3.nest()
//      .key(function(d) { return d.cluster; })
//      .entries(nodes);
//
//var root = d3.stratify()
//    .id(function(d) { return d.child; })
//    .parentId(function(d) { return d.parent; })
//    (nodes);
//
//
//var clusterholder = d3.cluster(root).size([width, height]);
//
////cluster sets the x and y of each node element ?!
//
//
//var node = chart.selectAll("circle")
//    .data(nodes)
//    .enter().append("circle")
//    .style("fill", function(d) { return 'blue';})
//    .attr('radius', '5')
//.call(clusterholder)
//;
//    
    //.nodeSize()






//    var yAxis = d3.axisLeft(yscale).tickSize(0).tickPadding([10]);
//    chart.append('g').attr('class', 'y-axis').call(yAxis);
//    var xAxis = d3.axisTop(xscale).tickValues([0, 10, 20, 30, 40, 50, 60]).tickSize(0);
//    chart.append('g').attr('class', 'x-axis').call(xAxis);    


//function generateRectangles(input, riskval){  
//    //RE-BIND DATA - children done separately
//    var rectholder =  chart.select('.rectholder').selectAll('.series').data(input[riskval].values, function(d){return d.type}); 
//    rectholder.selectAll('.bar-first').data(input[riskval].values, function(d){return d.type});
//    rectholder.selectAll('.bar-second').data(input[riskval].values, function(d){return d.type});  
//    
//    //stack a bunch of squares?
//    //and colors as two colors?
//    
//    //EXIT
//    d3.selectAll('.series').exit().transition().style('opacity', '0').remove();  
//       
////    //UPDATE (no data binding) 
//    d3.transition(updateTransition).selectAll('.bar-first')
//        .attr('y', function(d){return yscale(d.type)})      
//        .attr('height', yscale.bandwidth() + 'px')    
//        .attr('width', function(d){return xscale(d.secAvg)})
//    
//    d3.transition(updateTransition).selectAll('.bar-second')
//        .attr('x', function(d){return xscale(d.secAvg)})     
//        .attr('y', function(d){return yscale(d.type)})     
//        .attr('height', yscale.bandwidth() + 'px')
//        .attr('width', function(d){return xscale(d.primaryAvg)}); 
//
//    //ENTER
//    var series = rectholder.enter().append('g').attr('class', 'series');   
//    
//    series.append('rect').attr('class', 'bar-first')
//        .transition().styleTween('opacity', function(){return d3.interpolate(0, 1)})      
//        .attr('fill', function(d){return colorscale(d.type)})
//        .attr('x', '0px')
//        .attr('y', function(d){return yscale(d.type)})    
//        .attr('height', yscale.bandwidth() + 'px')
//        .attr('width', function(d){return xscale(d.secAvg)});
//    
//    series.append('rect').attr('class', 'bar-second')
//        .transition().styleTween('opacity', function(){return d3.interpolate(0, 1)})      
//        .attr('fill', function(d){return colorscale(d.type)})
//        .style('opacity', '.4')
//        .attr('x', function(d){return xscale(d.secAvg)})
//        .attr('y', function(d){return yscale(d.type)})    
//        .attr('height', yscale.bandwidth() + 'px')
//        .attr('width', function(d){return xscale(d.primaryAvg)});    
//        
//};


// function cardClick(){
//     var title = $(this).attr('title');
//     $('.content').fadeOut(200);
//     $('.content').fadeOut(200, function(){
//            window.location.href = 'projects/' + title ;
//     });
// };


//    filtered = origLineData.filter(function(d,i){ 
//       // console.log((d['cost'] <= yscale(rangeFilters['cost'][1]/100) || d['cost'] >= yscale(rangeFilters['cost'][0]/100) 
//        d['cost'] <= yscale(rangeFilters['cost'][1]/100) 
//            
//            //|| d['cost'] >= yscale(rangeFilters['cost'][0]/100) 
//   
////        && d['discharge'] >= rangeFilters['discharge'][1] && d['discharge'] < rangeFilters['discharge'][0] 
////        && d['income'] >= rangeFilters['income'][1] && d['income'] < rangeFilters['income'][0] 
////        && d['outcome'] >= rangeFilters['outcome'][1] && d['outcome'] < rangeFilters['outcome'][0]   
////        && d['patexp'] >= rangeFilters['patexp'][1] && d['patexp'] < rangeFilters['patexp'][0]         
//     });        

//    for (currFilterType in rangeFilters){   
//        var lowerFilterValue = rangeFilters[currFilterType][0];
//        var upperFilterValue = rangeFilters[currFilterType][1]; 
//        var lowerFilter, upperFilter;        
//        lowerFilter = yscale(lowerFilterValue/100);
//        upperFilter = yscale(upperFilterValue/100);   
//        
//        //concat made sense
//        //just a lower and upper array?
//        //lower array
//        //upper array
//        //or just include default filter values of .5 - no need for for loops
//        
//        if (lowerFilterValue && upperFilter){
//            filtered = filtered.filter(function(d,i){ return d[currFilterType] > lowerFilter && d[currFilterType] < lowerFilter });          
//        } 
//        else if (lowerFilterValue){
//            filtered = filtered.filter(function(d,i){ return d[currFilterType] > lowerFilter });          
//        } 
//        else if (upperFilterValue){             
//            filtered = filtered.filter(function(d,i){return d[currFilterType] < upperFilter });            
//        }; 
//        
    


//        if (lowerFilterValue){
//            filtered = origLineData.filter(function(d,i){ return d[currFilterType] > lowerFilter });
//            filteredCombined = filteredCombined.concat(filtered);            
//        } ;
//        if (upperFilterValue){             
//            filtered = origLineData.filter(function(d,i){return d[currFilterType] < upperFilter });  
//            filteredCombined = filteredCombined.concat(filtered);        
//        }; 
//        //array pushes combined filter
//        //in next round, we start filtering from filterCombined but we must empty it!!
//        
//        if (searchFilter.type){          
//            filtered = origLineData.filter(function(d,i){return d[searchFilter.type] === searchFilter.value });  
//            filteredCombined = filteredCombined.concat(filtered);           
//        };   



.ui-state-hover, .ui-widget-content .ui-state-hover, .ui-widget-header .ui-state-hover, .ui-state-focus, .ui-widget-content .ui-state-focus, .ui-widget-header .ui-state-focus {
    border: 1px solid #999999;
    font-weight: normal;
    color: #212121;
}

    <!--    <section class="slider-holder">-->
        
<!--
            <div class="slider-block income half-column">
                <div class="slider-label">income</div>
                <div class="slider horizontal">
                    <div class="thumb thumb-lower horizontal" filterType="income">
                        <div class="thumb-tooltip"></div>                        
                    </div>
                    <div class="thumb thumb-upper horizontal" filterType="income">
                        <div class="thumb-tooltip"></div>                        
                    </div>                        
                    <div class="fill-inner" filterType="cost"></div>                             
                </div>
            </div>
-->
        
//older d3 wording!!
//var yAxis = d3.svg.axis().scale(yscale).orient("left").tickSize(0).tickValues([]);
//var yAxis = d3.svg.axis().scale(yscale).orient("left").tickSize(0).tickValues([]);
//var yAxis = d3.select(".axis").call(yscale);
    //.transition().duration(3000).styleTween('stroke-opacity', function(){return d3.interpolate(0, 1)});
    
//    d3.select('.chart').transition().duration(1000).selectAll('.y-axis.axis').styleTween('stroke-opacity', function(){return d3.interpolate(0, 1)});  
    
//    updateTransition.select('.axisholder').selectAll('.y-axis.axis').styleTween('stroke-opacity', function(){return d3.interpolate(0, 1)});  
////        
        //.attr('transform', function(d, i){return "translate(" + d.value + ",0)" })
        
        //.transition().styleTween('stroke-opacity', function(){return d3.interpolate(0, 1)});

    
//    //ENTER ANIMATION (diff from update)
//    updateTransition.select('.axisholder').selectAll('.y-axis.axis').styleTween('stroke-opacity', function(){return d3.interpolate(0, 1)});
//        
    
//        updateTransition.select('.axisholder').selectAll('.y-axis.axis')
    //    //AXES    
//    var axishold = d3.select('.axisholder').selectAll('.y-axis.axis').data(axisDataObject, function(d){return d.name});
//    //UPDATE
//    updateTransition.select('.axisholder').selectAll('.y-axis.axis').attr('transform', function(d, i){return "translate(" + d.value + ",0)" });
//    
//    //ENTER
//    axishold.enter().append('g').call(yAxis).attr('class', 'y-axis axis').attr('transform', function(d, i){return "translate(" + d.value + ",0)" }).transition().styleTween('stroke-opacity', function(){return d3.interpolate(0, 1)});
//    
//    //EXIT
//    axishold.exit().remove().transition().styleTween('stroke-opacity', function(){return d3.interpolate(0, 1)});   
//    
    
    


//    updateTransition.select('.lineholder').selectAll('.polyline')
//        .attr("points", function(d){return generatePointArray(d)}).style("stroke", function(d, i){
//            if (d['cost'][1] > yscale(.5)){
//                console.log('ay');
//             return 'lightblue';
//           //  return "#00CED1";
//            }  
//            else {
//                return '#00CED1';
//               // return "#ff5050";
//            }});
    
//    var axislabel = d3.select('.axislabels').selectAll('.axis-label').data(axisArrangement[axisOrder.length]);
//    var updatelabel =
//    axislabel
//        .html(function(d,i){
//            return axisLabels[axisOrder[i]]  
//                               })        .on('mousemove', function(d, i){
//             tooltip.style("display", "block")
//               .html(function(){return axisLabelContent[axisOrder[i]] })
//            .style("left", d3.event.pageX-chartLeftOffset + "px")
//              .style("top", "10%")         
//    //          .style("left", Math.max(20, Math.min(80, 100*(d3.event.pageX)/$('.chartwrapper').width()-5 ))+ "%")
//    //          .style("top", "20%")
//               .style('width', '170px')
//                .style('background-color', 'rgba(255,255,255,.8)')
//             .style('box-shadow', '0 0 2px rgba(0,0,0,.3)')
//             .style('padding', '5px')
//             ;
//        }).on('mouseleave', function(){
//            tooltip.style('background', 'none').style('box-shadow', 'none').style('display', 'none').html('');
//        }); 
//    
//    
//    //fishy fish
//    updatelabel.transition().duration(800)
//            .style('left', function(d,i){
//            return Math.min(Math.max(1.5, 100*d/width), 97.5) + '%';
//        });
// 
//    
//    var enterlabel = 
//    axislabel.enter().append('div').attr('class', 'axis-label')
//        .html(function(d,i){
//        return axisLabels[axisOrder[i]]  
//                           })
//        .style('left', function(d,i){
//        return Math.min(Math.max(1.5, 100*d/width), 97.5) + '%';
//    })
//    .on('mousemove', function(d, i){
//         tooltip.style("display", "block")
//           .html(function(){return axisLabelContent[axisOrder[i]] })
//        .style("left", d3.event.pageX-chartLeftOffset + "px")
//          .style("top", "10%")         
////          .style("left", Math.max(20, Math.min(80, 100*(d3.event.pageX)/$('.chartwrapper').width()-5 ))+ "%")
////          .style("top", "20%")
//           .style('width', '170px')
//            .style('background-color', 'rgba(255,255,255,.8)')
//         .style('box-shadow', '0 0 2px rgba(0,0,0,.3)')
//         .style('padding', '5px')
//         ;
//    }).on('mouseleave', function(){
//        tooltip.style('background', 'none').style('box-shadow', 'none').style('display', 'none').html('');
//    });    
//    
//    axislabel.exit().remove();
//    
//    
//    //we neeeeed data update for axes!! object constantcy 
//    //do we keep by index
//    //need to decide now if we're going to allow for axis switching !!
//    
            
//                for (i=0; i<axisOrder.length; i++){
//            
//            console.log(i);
//            
//            //takes original and not scaled values
//            
//            var type = axisOrder[i];
//            var log = d[type];
//        d3.select('.chart').append("text").attr("class", "tooltip2")   
//            .style("display", "block")
//            .text(10)
//        .attr('x', '50').attr('y', '50')
////            .style("left", Math.min(99, Math.max(9, 4+100*this.points[i].x/900)) + "%")
////            .style("top", 100*this.points[i].y/450 + "%")            
//
//
//            }
//        for (i=0; i<axisOrder.length; i++){
//            
//            console.log(i);
//            
//            //takes original and not scaled values
//            
//            var type = axisOrder[i];
//            var log = d[type];
//        d3.select('.chart').append("g").attr("class", "tooltip2")   
//            .style("display", "block")
//            .html(10)
//            .style("left", Math.min(99, Math.max(9, 4+100*this.points[i].x/900)) + "%")
//            .style("top", 100*this.points[i].y/450 + "%")            
////        d3.select('.chart-height-holder').append("div").attr("class", "tooltip2")   
////            .style("display", "block")
////            .html(10)
////            .style("left", Math.min(99, Math.max(9, 4+100*this.points[i].x/900)) + "%")
////            .style("top", 100*this.points[i].y/450 + "%")
//
//            }
//        
//     lineholdG.selectAll('.circle').data(function(d){return generatePointArray(d)[0]}).enter().append('circle').attr('class', 'circle').attr('r', 2).attr('cx', function(d){return d[0]})
//     .attr('cy', function(d){return d[1]}).style('fill', 'black')
//      .on('mousemove', function(d, i){
//         console.log('circle');
//        tooltip.style("display", "block")
//            .html(function(d){return 'cost: ' + generatePointArray(d)[0]})
//          .style("left", "0px")
//          .style("top", "0px");
//    }).on('mouseleave', function(){
//        tooltip.style('display', 'none');
//    });
// ;  
//  
   // lineholdG.selectAll(.polyline('.circle').data([4, 4, 4]).enter().append('g').attr('class', 'circle');
    
    //    lineholdG.append('circle').attr('r', '.3').attr("points", function(d,i){ return generatePointArray(d) }).attr('cy', '').stroke('black');
         

//
//body .ui-autocomplete .ui-menu-item.ui-state-focus {
//    background-color: blue;
//    color: blue;
//        font-size:20px;
//}
//
//
//
//.ui-autocomplete li.ui-menu-item a:focus
//{
//    color:blue;
//    background:#96B202;
//    outline:none;
//       display:none;
//}
//.ui-menu-item-wrapper:focus
//{
//    color:blue;
//    background:#96B202;
//    outline:none;
//       display:none;
//}
//.ui-menu .ui-menu-item a.sbiAnchor.ui-state-hover{
//    background: blue;
//       display:none;
//}
//.ui-state-focus
//{
//    color:blue;
//    display:none;
//    background:#96B202;
//    outline:none;
//}
//.ui-menu-item-wrapper:focus {
//    color: blue;
//}
////.ui-menu-item:hover {
////    color: blue;
////}
//.ui-auto
//li:focus {
//    color:green;
//        display: block;
//       display:none;
//}
//
////#tags:focus {
////    color:blue;
////}
//.ui-menu-item:hover
//{
//    color:blue;
//}
//
//.ui-menu-item:focus
//{
//    color:red;
//}



//var attributeFilters = {
//    state: [ALL]
//}

//for each filter in filters

//functionGetInitialFilters() = {
//    max and min of each value
//}
//
//slider is moved .. 
//
//
//(x, 20, 30, null, cost)

//    if (equals){
//        return currData = input.filter(function(d,i){return d[type] === equals});       
//    }
//    else if (lowerbound && upperbound ){
//        return currData = input.filter(function(d,i){return d[type] < lowerbound && d[type] > upperbound});          
//    };



//issue of applying two filters? dataset < .7, then we say cost > /8
//anytime filter is changed must register both upper and lower

   
//    update(data.filter(function(d,i){return d.cost > .7}), axes);
    
//sliders
//    output - 0 to 100 scale
//attributes - types (state, income > )
//    always filter original data ? ? ?
    //or just current data




            // data = data.sort(function(a,b){return d3.descending(+a.discharge, +a.quality)});
         // var data = data.filter(function(d,i){return d.cost>.9 && d.discharge > 0});
         
//    var data = data.filter(function(d,i){return d.state === 'ri'});
//    
//    function generateFilter(type, lowerbound, upperbound){
//        var data = data.filter(function(d,i){return d.cost>.9});
//    };
//    


















//                        .attr("points", function(d, i){
//                            return Object.keys(d.points).map(function(key){return d.points[key]} )
//                        });     

//       var alldata2 =  [discharge, outcome, patexp, cost] ;
      // data.map(function(d){    
//          cost.push(ycost(+d.cost));
//          quality.push(yquality(+d.quality));
//          efficiency.push(ycost(+d.efficiency));
//          patexp.push(ycost(+d.patexp));
//          outcome.push(ycost(+d.outcome));
//          strokewidth.push(d.strokewidth);
//          bubblesize.push(+d.bubblesize);
//          return discharge.push(ydischarge(+d.discharge));
//        }); 

   // var cost, quality, discharge, efficiency, patexp, outcome, bubblesize;
//    var color, strokewidth; cost = [];  quality = []; discharge = []; efficiency = [];
//    patexp = [];  outcome = []; color = []; strokewidth = []; bubblesize = [];
    
    
        //                chart.select('.lineholder').append("polyline")
//                    .style("stroke", colorscale(i)) 
//                    .style("fill", "none")  
//                    .style("fill", "none")  
//                    //.style ('stroke-width', '.25px') 
//                    .style ('stroke-width', currwidth) 
//                    .attr("points", currTrans)
//                    .on("mouseover", function(){
//                        console.log([d, provMap[i]]);
//                    });  
    
    
    
//                    .on("mouseover", function(){
//                        console.log([d, provMap[i]]);
//                    });  
    
//    console.log(axes[0]);
    
//    console.log(Object.keys(axes) );
//    chart.selectAll('y-axis').data( Object.keys(axes) ).enter().append('g').attr('class', 'y-axis').call(axes[data]);
        
//        .attr("transform", "translate(" +axes[data] + ",0)");
    
//    .call(yaxes[i]).attr("transform", "translate(" + xvalues[i] + ",0)");
    
    

    //polyline two separate bindings
        //filter hospital name, etc easily
    
//    d3.select()
    
    //line per axis or polyline

    
//    var axes = [{'discharge': discharge},{'outcome': outcome},{'patexp': patexp},{'cost': cost}] ;
    
//    console.log(axes.keys());
    
    
//    console.log(  Object.keys(axes)[0] );
//   console.log(  Object.keys(axes) );    
////    

    
      
      //alldata2 formatted by columns

       //four axes
    
     //var xvalues = [0, width*.4, width*.56, x3]

      //array created for scales, axes so that correct object is applied in for loop

      //var scales = [ycost, yincome, yquality, ydischarge];
     // var yaxes = [yaxiscost, yaxiseff, yaxispatexp, yaxisoutcome, yaxisdischarge];


      //for LINE  
      //below getting y values (rows) of data to create lines
//      function transpose(a) {
//          return Object.keys(a[0]).map(
//              function (c) { return a.map(function (r) { return r[c]; }); }
//              );
//          }
//        var yvalrows = transpose(alldata2);
//        var numRows =  yvalrows.length;
//        var numColumns = alldata2.length;
//
//      var colorscale = d3.scale.linear()
//          .domain([0, numRows])
//            .range(["#00CED1", "#ff5050"]); 
//
//        //create 2d array for line x values
//        var xvalrows = [];
//            for (j = 0; j < numRows; j++) { 
//                xvalrows.push(xvalues);
//            }        
//        //ay u want lines?
//
//    chart.append('g').attr('class', 'lineholder');
//      
    
    
    
     //chart.selectAll('.lineholder').data()
      
//      d3.select('.lineholder').selectAll('g').data(yvalrows).enter().append('g').attr('class', 'line');
//      
//      d3.selectAll('.line').data
//      
//      .attr(points)

//        yvalrows.forEach(function(d, i){ //for each row, create a line
//
//                  var currcolor = colorscale(i);
//                  var currxvalrows = xvalrows[i];
//                  var curryvalrows = yvalrows[i];
//                  var currdata = [currxvalrows, curryvalrows];
//                  var currTrans = transpose(currdata);
//                  var currwidth = strokewidth[i];
//
//                  var line = d3.svg.line()
//                        .x(function(d, i) {
//                            return d[0]; //formatted as 4 col, x row array
//                        })
//                        .y(function(d, i) {
//                            return d[1];
//                        })
//                        .interpolate("linear")
//// .               style("stroke", function() {
////                 return d.color = color(d.key); })
//                        ;
//
//                console.log(currTrans);
//
//                chart.select('.lineholder').append("polyline")
//                    .style("stroke", colorscale(i)) 
//                    .style("fill", "none")  
//                    .style("fill", "none")  
//                    //.style ('stroke-width', '.25px') 
//                    .style ('stroke-width', currwidth) 
//                    .attr("points", currTrans)
//                    .on("mouseover", function(){
//                        console.log([d, provMap[i]]);
//                    });  
//        })

      
     // chart.select('.axisholder').selectAll('g').data(alldata2).enter().append('g').attr('class', 'y axis');
    
    
//        chart.append('g').attr('class', 'axisholder');
//      alldata2.forEach(function(d, i) {
//          var currVal = alldata2[i];
//          chart.select('.axisholder').append('g').attr('class', 'y axis').call(yaxes[i]).attr("transform", "translate(" + xvalues[i] + ",0)");
//    }); 


//         chart.append('g').attr('class', 'circleholder').selectAll('circle').data(alldata2[i]).enter().append(".circleholder:circle")   
//            .attr("cx", xvalues[i])
//            .attr("cy", function(d, i) { return currVal[i]; }) //can take str8 arrays! d, i based off array 
//            //.attr("r", '100');
//            .attr("r", function(d, i) { return bubblesize[i]; })
//            .attr('fill', 'darkgrey')
//            ;


//        var x1 = 0;
//        var x2 = 1.5*width/3 ;
//        var x3 = width ;
//        var x4 = width ;
    




//.home-button {
//    position: fixed;
//    z-index: 1000;
//    width: 20px;
//    height: 20px;
//    top: 3rem;
//    right: 1.5%;
//    opacity: .7;      
//}
//
//.image-button {
//    position: fixed;
//    z-index: 1000;
//    width: 25px;
//    height: 25px;
//    top: 6rem;
//    right: 1.5%; 
//    box-shadow: 0 1px 1px rgba(0, 0,0, .3);
//    border-radius: 100%; 
//    opacity: .7
//}
//.text-button {
//     position: fixed;
//    z-index: 100;
//    width: 25px;
//    height: 25px;
//  //  background-color: $project-info-color;
//    top: 8rem;
//    right: 1.5%;
//        box-shadow: 0 1px 1px rgba(0, 0,0, .3);
//    border-radius: 100%;
//    opacity: .7;    
//}
//.project-info-button {
//    position: fixed;
//    right: 1.5%;
//    top: 0%;
//    width: 1.5rem;
//    z-index: 1000;
//    height: 1.5rem;
//    
////    width: $project-info-padding-bottom - .2rem;
////    height: $project-info-padding-bottom - .2rem;
//    background-color: white;   
//  //  border: 1px solid white;
//}


//<!--
//<link href='https://fonts.googleapis.com/css?family=Quicksand' rel='stylesheet' type='text/css'>
//
//<script type="text/javascript">
//    (function() {
//        var path = '//easy.myfonts.net/v2/js?sid=187188(font-family=Brandon+Grotesque+Regular)&sid=187189(font-family=Brandon+Grotesque+Light)&sid=187190(font-family=Brandon+Grotesque+Bold)&sid=187194(font-family=Brandon+Grotesque+Medium)&key=YyAjJbV0Mu',
//            protocol = ('https:' == document.location.protocol ? 'https:' : 'http:'),
//            trial = document.createElement('script');
//        trial.type = 'text/javascript';
//        trial.async = true;
//        trial.src = protocol + path;
//        var head = document.getElementsByTagName("head")[0];
//        head.appendChild(trial);
//    })();
//</script>
//-->

//
//function(event){ //stop listening
//            if (currCard){
//                currCardClassChange(currCard, 'card-selector', currCard.attr('default'));                
//            }
//            currCard = null;
//            $('.cardholder').unbind('mousemove');
//            $('.card').unbind('mouseenter');
//    
//        }  


//        function(event){
//        
//            var prevX;
//            var prevMove, currMove;
//            var next;
//            var initialX;
//            var prevDirection;
//            var currHolder = $(this);
//            $('.card').one('mousemove', function(event2){            //MAKE SURE THIS RUNS JUST ONCE!!
//                $('.card').unbind('mousemove');             
//                initialX = parseFloat(event.pageX) - parseFloat($(currHolder).offset().left);
//                currCard = $(this); //enter selects child
//                   
//                $(currHolder).mousemove(function(event){ 
//                    
//                    currCardClassChange(currCard, currCard.attr('default'), 'card-selector');
//                    var currX = parseFloat(event.pageX) - parseFloat($(this).offset().left);  
//                    var currDirection = parseFloat(currX - prevX); 
//                    //update initialX if direction switched
//                    if (prevX && prevDirection){   
//                        var directionSwitch = Math.sign(currDirection)*Math.sign(prevDirection)==-1;
//                        if (directionSwitch){
//                            initialX = prevX;
//                        };                         
//                    };
//                    //detect if mouse movement has passed critical threshold to flip cards
//                    var currMove = (currX-initialX)/parseFloat($(this).width());
//                    var criticalMove = Math.abs(currMove) > fractionIncrement;    
//                    if (criticalMove){
//                        initialX = currX;      
//                        //new card coming in
//                        if (currCard !== getCardInSequence(currCard, currDirection) ){
//                            
//                            currCardClassChange(currCard, 'card-selector', currCard.attr('default'));
//                            currCard = getCardInSequence(currCard, currDirection);
//                            currCardClassChange(currCard, currCard.attr('default'), 'card-selector');                      
//                        }                                    
//                    };
//                    if (prevX) {
//                        prevDirection = parseFloat(currDirection);
//                    };
//                    prevX = currX;
//                    prevMove = currMove;
//                });    
//                
//            });
//        }


//@media only screen and (max-width: 1035px)
//    {
//        .content {
//        width: 96vw; 
//        }
//    }


//.card.tags {
//    transform: translateX($tagcard-translateX) translateY($tagcard-translateY);
//    opacity: $tagcard-opacity;
//    z-index: 2;
//}
//.card.thumbnail {
//    transform: translateX($thumbnailcard-translateX) translateY($thumbnailcard-translateY);
//    opacity: $thumbnailcard-opacity;    
//    z-index: 3;
//}
//.card.synposis {
//    transform: translateX($synposiscard-translateX) translateY($synposiscard-translateY);    
//    opacity: $synposiscard-opacity;  
//    z-index: 4;
//    box-shadow: 0 .5px .5px 0px black;    
//}







//                        if (Math.sign(currDirection)*Math.sign(prevDirection)==1)
//                        {
//                            directionSwitch = true;
//                            initialX = prevX;
////                            console.log('directionswitch', directionSwitch);
//                        };   
                        
//                        currCard.css('background-color', 'yellow');
//                        if (currX > prevX){
//    //                        getCardInSequence(currCard, 1)
//                            currMovingRight = true;
//                        }
//                        else if (currX < prevX){
//    //                        getCardInSequence(currCard, -1)                    
//                            currMovingRight = false;   
//                        };        





//    var getCardInSequence = function(card, next){
//        
//        var order = parseInt(card.attr('order'));
//        var title = card.attr('title');
//        var nextCard;
//        //reached end of stack
//        if ( (order == 3 && next==-1) || (order == 1 && next==1)  ){
////           return null;
//        }
//        else {
//            var ordernext = parseInt(order) - parseInt(next);
//            nextCard = $('.'+ title).find("div[order=" + ordernext + "]");
////            currCard.css('background-color', 'blue');
//            currCard = nextCard;
//        };
//    };
//    



//    
//    $('.cardholder').mouseover(function(event){
//           
//        $('.cardholder').mousemove(function(event){
//            var newX = event.pageX - $(this).offset().left;
//            var newY = event.pageY - $(this).offset().top;
//            if (!currX){
//                currX = newX;
//            }
//            if (currCard){
//                currCard.css('background-color', 'yellow');
//                if (newX > currX){
//                    getCardInSequence(currCard, 1)
//                    movingRight = true;
//                    movingLeft = false;
//                }
//                else if (newX < currX){
//                    getCardInSequence(currCard, -1)                    
//                    movingRight = false;
//                    movingLeft = true;       
//                }; 
//            }
//            currX = newX;
//
//        });
//        //fires multiple times before leave event!
//
//        
//    });
    














//function gets horizontal distance two cards, used as gauge for amount of distance mouse should before to elicit 'card flip'
//var getXIncrementCard = function(){
////    var cardholder = $('.cardholder').first();
////    var thirdCardLeft = parseFloat(cardholder.find('.card3').first().position().left);
////    var secondCardLeft = parseFloat(cardholder.find('.card2').first().position().left);
////    return fractionIncrement = Math.abs((secondCardLeft - thirdCardLeft)/ parseFloat(cardholder.width()));
//    return fractionIncrement = 
//};
//            getXIncrementCard();


//6/20 morning

//old js
//var setLayout = function(categoryFile, projectFile){
//    d3.csv(categoryFile, function(categories){
//        d3.csv(projectFile, function(projects){ 
//             for (i=0; i<categories.length; i++){
//                var projectsByCategory = projects.filter(function(d){return d.category === categories[i].category;});  
//                if (categories[i].layout == 'left'){
//                      generateCSS($('.content'), categories[i], projectsByCategory);
//
//                  }
//                else if (categories[i].layout == 'right'){
//                      generateCSS($('.content'), categories[i], projectsByCategory);
//                  };
//              };       
//        });   
//    });
//};
//
//
////card coloring should be done based on classes
//    
//var generateCSS = function($contentholder, category, projects){
//    var categoryHolder = $contentholder.find('.' + category.category);
//
//    for (var i=0; i<projects.length; i++){
//        var cardHolder = categoryHolder.find('.cardholder.' +projects[i].title);
//        var cardholderStyle = {
//            'width': projects[i].width,
//            //maintain aspect ratio           
//            'height': .73*parseInt(projects[i].width)+'vw',            
//            'position': projects[i].position,
//            'top': projects[i].top,
//            'left': projects[i].left,
//            'border-radius': projects[i].borderradius}
//        cardHolder.css(cardholderStyle);
// 
//        var numCards = parseInt(projects[i].numCards);
//        var currVal = 6;
//        var offset = 6;
//        //this below needs to be generative
//        var cardCats = ['thumbnail', 'synposis', 'tags'];
//        opacity = [.2, .4, .9];
//        for (var j=0; j<numCards; j++){
//            currOpacity = opacity[j];
//            //very weak please fix
//            var card = cardHolder.find('.card.' + cardCats[j] + '.' + projects[i].title);     
//            var cardStyle = {
//                'width': '85%',
//                'height': '85%',
//                'transform': 'translateX(' + currVal + '%) translateY(' + currVal + '%)',
//                'background-color': projects[i].backgroundcolor,
//                'border-radius': projects[i].borderradius,
//                'position': 'absolute',
//                'font-size': projects[i].fontsize,
//                'opacity': currOpacity,
//                'color': 'white',
//                'z-index': j};  
//                
//            card.css(cardStyle);
////            if (j == numCards -1){
////                card.append('<p>' + projects[i].synposis + '</p>')  
////            };
//      
//            currVal = currVal+offset;
//            }
//    };        
//};


//    .leftcontent {
////        height: 42rem;  
//    //    background-color: blue;
//        float: left;
//        //width: 47rem;
//        height: 100%;
//        width: 100%
//    }
//
//    .rightcontent {
////        width: 300px;
//        width: 35%;
//        height: 100%;
//        float: left;
//        //height: 42rem;  
//    }
//
//
//
//    .leftcontent section:nth-child(1) {
//        width: 100%;
//        height: 55%;
////        border: .5px dotted black;
////    //    background-color: black;  
//        position: relative;
//
//    }
//    .leftcontent section:nth-child(2) {
//        width: 100%;
//        height: 45%;
////        border: .5px dotted black;
//        position: relative;    
//    }
//
//    .rightcontent section:nth-child(1) {
//          width: 100%;
//        height: 100%;
////        border: .5px dotted black;    
//        position: relative;    
//    }



//    .hospital {
//        background-color: blue;
//    //    width: 250px;
//    //    height: 185px;
////        width: 40%;
////        padding: 15%; 
//        height: 18vw;
//        width: 25vw;
//        position: absolute;
//        top: 19%;
//        left: 5%;
//        border-radius: 9%;
//    }
//
//    .rx {
//        background-color: blue;
////        width: 31%;
////        padding: 12%;
//        height: 13vw;
//        width: 18vw;        
//        position: absolute;
//        top: 5%;
//        left: 52%;  
//            border-radius: 9%;
//    }
//
//    .personaldata {
//        background-color: blue;
////        width: 27%;
////        padding: 10%;
//        height: 11vw;
//        width: 15vw;           
//        position: absolute;
//        top: 60%;
//        right: 5%;    
//        border-radius: 9%;    
//    }
//
//    .thesis{
//        background-color: red;
////        width: 34%;
////        padding: 13%;
//       height: 15vw;
//        width: 22vw;         
//        position: absolute;
//        top: 0%;
//        left: 15%;     
//                border-radius: 9%;
//    }
//    .narrative{
//        background-color: red;
////        width: 28%;
////        padding: 10%;
//        
//        width: 15vw;
//        height: 11vw;
////        height: 40%;
//
////        width: 150px;
////        height: 110px;
//        position: absolute;
//        top: 42%;
//        left: 60%;   
//        border-radius: 9%;
////        color: white;
////        font-size: 8px;
//        font-size: 1.5vw;
//        text-align: center;
//    }
//    
//    .narrative p {
//        color: white;
//        font-size: 1.5vw;
//        position: absolute;
//        top: 0;
//        left: 0;
//        right: 0;
//        bottom: 0;
//    }
//
//    .tools {
//        background-color: green;
////        width: 30%;
////        padding: 12%;
//        width: 15vw;
//        height: 11vw;
//        position: absolute;
//        top: 20%;
//        left: 35%;   
//            border-radius: 9%;
//    }
//    .table {
//        background-color: green;
////        width: 30%;
////        padding: 12%;
//        width: 14vw;
//        height: 10vw;        
//        position: absolute;
//        top: 50%;
//        left: 5%;     
//        border-radius: 9%;
//    }
//    .tea {
//        background-color: green;
////        width: 150px;
////        height: 110px;
//        width: 15vw;
//        height: 11vw;        
//        position: absolute;
//        top: 75%;
//        left: 20%;    
//        border-radius: 9%;
//    }
//    
//
//}




//
//@media (max-width: 320px){
//    
//    html {font-size: 112%;}
//    
//    .column{
//        float: left;
//        padding-left: 1rem;
//        padding-right: 1rem;
//    }
//    
//    .column.full {width: 100%;}
//    .column.two-thirds {width: 66.7%;}
//    .column.half {width: 50%;}
//    .column.third {width: 33.3%;}
//    .column.fourth {width: 25%;}
//    .column.flow-opposite {float: right;}
//}
//



//.leftcontent:nth-child(2) {
//    width: 100%;
//  background-color: black;  
//}

//
//<!--
//       {% for category in site.data.categories %}
//            {% if category.layout == 'left' %}
//                       <section class="{{category.category}}">
//                  {% for project in site.data.projects %}
//                              {% if category.category == project.category %}
//                                 <div class="cardholder {{project.title}}" style="color:{{project.color}}; width: {{project.width}}; height: {{project.height}}; position: {{project.position}}; top: {{project.top}}; left: {{project.left}}; border-radius: {{project.border-radius}}">
//                                    <div class="card thumbnail {{project.title}}" style="opacity: .2; background-color: {{category.color}}; width: 85%; height: 85%; transform: translateX(6%) translateY(6%); border-radius: {{project.border-radius}}; position:absolute; z-index: 1; font-size: {{project.font-size}}"></div>  
//                                    <div class="card synposis {{project.title}}" style="opacity: .42; background-color:{{category.color}}; width: 85%; height: 85%; transform: translateX(12%) translateY(12%); border-radius: 9%; position: absolute; z-index: 2; font-size: {{project.font-size}}"></div>
//                                    <div class="card tags {{project.title}}" style="opacity: 1;  position:absolute; width: 85%; height:85%; background-color:{{category.color}}; transform: translateX(18%) translateY(18%); border-radius: {{project.border-radius}}; z-index: 3; font-size: {{project.font-size}}; box-shadow: 0 1px 0px 0px grey"><p>{{project.title}}</p></div>
//                           
//                                </div>
//                            {% endif %}
//                  {% endfor %}
//                        </section>
//            {% endif %}
//      {% endfor %}
//-->

//
//
//<!--
//       {% for category in site.data.categories %}
//            {% if category.layout == 'right' %}
//                       <section class="{{category.category}}">
//                  {% for project in site.data.projects %}
//                              {% if category.category == project.category %}
//                                 <div class="cardholder {{project.title}}" style="color:{{project.color}}; width: {{project.width}}; height: {{project.height}}; position: {{project.position}}; top: {{project.top}}; left: {{project.left}}; border-radius: {{project.border-radius}}">
//                                     
//                                        <div class="card thumbnail {{project.title}}" style="opacity: .2; background-color: {{category.color}}; width: 85%; height: 85%; transform: translateX(8%) translateY(8%); border-radius: 9%; position:absolute; z-index: 1; font-size: {{project.font-size}}"></div>                    
//                                        <div class="card synposis {{project.title}}" style="opacity: .42; background-color:{{category.color}}; width: 85%; height: 85%; transform: translateX(13%) translateY(13%); border-radius: {{project.border-radius}}; position: absolute; z-index: 2; font-size: {{project.font-size}}"></div>
//                                        <div class="card tags {{project.title}}" style="opacity: 1;  position:absolute; width: 85%; height:85%; background-color:{{category.color}}; transform: translateX(18%) translateY(18%); border-radius: {{project.border-radius}}; z-index: 3; font-size: {{project.font-size}}; box-shadow: 0 1px 0px 0px grey"><p>{{project.title}}</p></div>
//                                     
//                                </div>
//                            {% endif %}
//                  {% endfor %}
//                        </section>
//            {% endif %}
//      {% endfor %}
//-->




//$(window).resize(function(){
//   //if this is a new size, recalculate css
//});


//        if (i==numCards-1){
//            .css(box-shadow: 0 1px 0px 0px grey);
//        }


//
//{% if category.category == project.category %}
//                                 <div class="cardholder {{project.title}}" style="color:{{project.color}}; width: {{project.width}}; height: {{project.height}}; position: {{project.position}}; top: {{project.top}}; left: {{project.left}}; border-radius: {{project.border-radius}}">
//                                    <div class="card thumbnail {{project.title}}" style="opacity: .2; background-color: {{category.color}}; width: 85%; height: 85%; transform: translateX(6%) translateY(6%); border-radius: {{project.border-radius}}; position:absolute; z-index: 1; font-size: {{project.font-size}}"></div>  
//                                    <div class="card synposis {{project.title}}" style="opacity: .42; background-color:{{category.color}}; width: 85%; height: 85%; transform: translateX(12%) translateY(12%); border-radius: 9%; position: absolute; z-index: 2; font-size: {{project.font-size}}"></div>
//                                    <div class="card tags {{project.title}}" style="opacity: 1;  position:absolute; width: 85%; height:85%; background-color:{{category.color}}; transform: translateX(18%) translateY(18%); border-radius: {{project.border-radius}}; z-index: 3; font-size: {{project.font-size}}; box-shadow: 0 1px 0px 0px grey"><p>{{project.title}}</p></div>
//
//       {% for category in site.data.categories %}
//            {% if category.layout == 'left' %}
//                       <section class="{{category.category}}">
//                  {% for project in site.data.projects %}
//                              {% if category.category == project.category %}
//                                 <div class="cardholder {{project.title}}" style="color:{{project.color}}; width: {{project.width}}; height: {{project.height}}; position: {{project.position}}; top: {{project.top}}; left: {{project.left}}; border-radius: {{project.border-radius}}">
//                                    <div class="card thumbnail {{project.title}}" style="opacity: .2; background-color: {{category.color}}; width: 85%; height: 85%; transform: translateX(6%) translateY(6%); border-radius: {{project.border-radius}}; position:absolute; z-index: 1; font-size: {{project.font-size}}"></div>  
//                                    <div class="card synposis {{project.title}}" style="opacity: .42; background-color:{{category.color}}; width: 85%; height: 85%; transform: translateX(12%) translateY(12%); border-radius: 9%; position: absolute; z-index: 2; font-size: {{project.font-size}}"></div>
//                                    <div class="card tags {{project.title}}" style="opacity: 1;  position:absolute; width: 85%; height:85%; background-color:{{category.color}}; transform: translateX(18%) translateY(18%); border-radius: {{project.border-radius}}; z-index: 3; font-size: {{project.font-size}}; box-shadow: 0 1px 0px 0px grey"><p>{{project.title}}</p></div>
//                           
//                                </div>
//                            {% endif %}
//                  {% endfor %}
//                        </section>
//            {% endif %}
//      {% endfor %}



//d3.csv('datacopy/categories.csv', function(data){
//
//    
//    console.log(data);
//});
//



//$(window).resize(function(event) {
//  console.log( $(window).width() );
//   
//});


//project sizing and locations handled here
//takes input from csv file
